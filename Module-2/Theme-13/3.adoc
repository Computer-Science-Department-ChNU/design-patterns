=== 1.3. Підйом тіла конструктора (Pull Up Constructor Body)

*Проблема*

Підкласи мають конструктори з переважно однаковим кодом.

[source, java]
----
class Manager extends Employee {
  public Manager(String name, String id, int grade) {
    this.name = name;
    this.id = id;
    this.grade = grade;
  }
  // ...
}
----

*Рішення*

Створіть конструктор в суперкласі і винесіть в нього спільний для підкласів код. Викликайте конструктор суперкласу в конструкторах підкласу.

[source, java]
----
class Manager extends Employee {
  public Manager(String name, String id, int grade) {
    super(name, id);
    this.grade = grade;
  }
  // ...
}
----


*Причини рефакторингу*

Чим цей рефакторинг відрізняється від підйому методу?

. У Java підкласи не можуть наслідувати конструктор, тому ви не можете просто застосувати підйом методу до конструктора підкласу і видалити його після переміщення усього коду конструктора в суперклас. На додаток до створення конструктора в суперкласі треба буде мати конструктори в підкласах з простим делегуванням до конструктора суперкласу.

. В C++ і Java (у разі, якщо ви явно не викликали конструктор суперкласу) конструктор суперкласу автоматично викликається перед конструктором підкласу, що робить обов’язковим переміщення спільного коду тільки з початку конструкторів підкласів (оскільки ви не зможете викликати конструктор суперкласу в довільному місці конструктора підкласу).

. У більшості мов програмування конструктор підкласу може мати свій власний список параметрів, відмінний від параметрів суперкласу, тому ви повинні створити конструктор суперкласу тільки з тими параметрами, які йому дійсно потрібні.

*Порядок рефакторингу*

. Створіть конструктор в суперкласі.

. Витягніть спільний код з початку конструктора кожного з підкласів в конструктор суперкласу. Перед цією дією варто спробувати помістити якомога більше спільного коду в початок конструктора.

. Розташуйте виклик конструктора суперкласу першим рядком в конструкторах підкласів.