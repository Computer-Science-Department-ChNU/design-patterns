== 5. Заплутувальники зв'язками

Всі запахи з цієї групи призводять до надлишкової зв’язаності між класами, або показують, що буває якщо тісна зв’язаність заміщується постійним делегуванням.

=== 5.1. Заздрісні функції (Feature Envy)

*Симптоми і ознаки*

Метод звертається до даних іншого об’єкта частіше, ніж до власних даних.

*Причини появи*

Цей запах може з’явитися після переміщення якихось полів в клас даних. В цьому випадку операції з даними, можливо, також слід перемістити в цей клас.

*Лікування*

Слід дотримуватися такого правила: те, що змінюється разом, треба зберігати в одному місці. Зазвичай дані і функції, які використовують ці дані, також змінюються разом (хоча бувають виключення).

* Якщо метод явно слід перенести в інше місце, застосуйте переміщення методу.
* Якщо тільки частина методу звертається до даних іншого об’єкта, застосуйте відокремлення методу до цієї частини.
* Якщо метод використовує функції декількох інших класів, треба спочатку визначити, в якому класі знаходиться найбільше даних, що використовуються. Потім слід перемістити метод в цей клас разом з іншими даними. Як альтернатива, за допомогою відокремлення методу метод розбивається на декілька частин, і вони розміщуються в різних частинах інших класів.

*Виграш*

* Зменшення дублювання коду (якщо код обробки даних переїхав в одне загальне місце).
* Поліпшення організації коду (оскільки методи роботи з даними знаходяться біля цих даних).

*Не варто чіпати, якщо...*

Бувають випадки, коли поведінка навмисно відділяється від класу, що містить дані. Найчастіше це роблять для того, щоби мати можливість динамічно міняти цю поведінку (патерни Стратегія, Відвідувач і так далі).

=== 5.2. Недоречна близькість (Inappropriate Intimacy)

*Симптоми і ознаки*

Один клас використовує службові поля і методи іншого класу.

*Причини появи*

Дивіться уважно за класами, які проводять надто багато часу разом. Хороші класи повинні знати один про одного якомога менше. Такі класи легше підтримувати і повторно використовувати.

*Лікування*

* Найпростіший вихід - за допомогою переміщення методу і переміщення поля перенести частини одного класу в інший (в той, де вони використовуються). Проте це може спрацювати тільки в тому випадку, якщо оригінальний клас не використовує переміщувані поля і методи.
* Іншим рішенням є відокремлення залежних частин в окремий клас і приховання делегування до цього класу.
* Якщо між класами існує взаємна залежність, варто використати заміну двонаправленого зв’язку на однонапрямлену.
* Якщо близькість виникає між підкласом і батьківським класом, краще розглянути можливість заміни делегування наслідуванням.

*Виграш*

* Покращує організацію коду.
* Спрощує технічну підтримку і повторне використання коду.

[#_message_chains_heading]
=== 5.3. Ланцюжок викликів (Message Chains)

*Симптоми і ознаки*

Ви бачите в коді ланцюжок викликів на зразок такого $a->b()->c()->d()

*Причини появи*

Ланцюжок викликів з’являється тоді, коли клієнт запитує один об’єкт щодо іншого, у свою чергу цей об’єкт запитує ще один і т. д. Такі послідовності викликів означають, що клієнт є пов’язаний з навігацією по структурі класів. Будь-які зміни проміжних зв’язків означають, що клієнт потрібно буде модифікувати.

*Лікування*

* Для видалення ланцюжка викликів застосовується прийом прихованого делегування.
* Іноді краще розглянути, для чого використовується кінцевий об’єкт. Можливо, має сенс використати відокремлення методу, щоб витягнути цю функціональність і перенести її в самий початок ланцюга за допомогою переміщення методу.

*Виграш*

* Зменшується зв’язність між класами ланцюжка.
* Зменшується розмір коду.

*Не варто чіпати, якщо...*

Якщо ви перестараєтеся в процесі приховування делегування, в коді буде досить складно зрозуміти, де саме здійснюється конкретна робота. Іншими словами, з’явиться запах <<#_middle_man_heading,Посередник>>.

[#_middle_man_heading]
=== 5.4. Посередник (Middle Man)

*Симптоми і ознаки*

Якщо клас виконує тільки одну дію — делегує роботу іншому класу - варто замислитись, навіщо він взагалі існує.

*Причини появи*

Цей запах може бути результатом фанатичної боротьби з <<#_message_chains_heading,ланцюжками викликів>>.

Також іноді буває, що все корисне навантаження класу поступово переноситься в інші класи, в результаті окрім делегуючих методів в ньому нічого не залишається.

*Лікування*

Якщо більшу частину методів клас делегує іншому класу, треба скористатися видаленням посередника.

*Виграш*

Зменшення розміру коду.

*Не варто чіпати, якщо...*

Не видаляйте посередників, які були створені свідомо:

* Посередник міг бути введений для позбавлення від небажаної залежності між класами.
* Деякі патерни проектування навмисно створюють посередників (наприклад Замісник чи Декоратор).
