= Вступ до рефакторингу
:toc:
:toc-title: Зміст

== 1. Чистий код
Рефакторинг - це, в першу чергу, перетворення брудного коду в чистий.

* Чистий код проходить усі тести: якщо програма проходить тільки 95% тестів, значить десь у вас завівся брудний код, якщо у вас взагалі немає тестів, ви не проходите цей пункт автоматично.
* Чистий код очевидний для інших програмістів:
погане іменування змінних, роздуті класи й методи - все це розмиває очевидність коду.
* Чистий код не містить дублювання:
якщо доводиться змінювати ділянку коду з дублюванням, потрібно буде не забути внести такі самі зміни й в інших місцях, де код повторюється.
* Чистий код містить мінімум класів та інших рухомих частин: чим менше коду, тим менше деталей потрібно тримати в пам’яті. Чим менше коду, тим менше ймовірність щось зламати.
* Чистий код легше і дешевше підтримувати!

== 2. Технічний борг
Всі люди намагаються писати чистий код від початку проєкт. Навряд чи знайдеться програміст, який буде навмисно плодити брудний код. Але чому тоді чистий код стає брудним?

Вперше метафору https://wiki.c2.com/?WardExplainsDebtMetaphor[«технічного боргу»], щодо брудного коду, запропонував Говард Канінгем.

Взявши у банку кредит, ви можете пришвидшити якесь придбання. Однак повернути вам потрібно буде не тільки основну суму кредиту, але й додаткові відсотки, які будуть нараховуватися доти, поки ви повністю не розрахуєтеся з банком.

Також, ви можете взяти декілька кредитів одночасно. Ба більше — ви можете набрати стільки кредитів, що сума відсотків переважить ваш сукупний дохід і зробить повне погашення неможливим.

Те ж відбувається і з кодом. Сьогодні ви тимчасово прискорюєтеся, не написавши тести для нової фічі, але тепер це буде потроху сповільнювати прогрес кожен день в майбутньому. До тих пір, поки ви не погасите борг, все-таки написавши тести.

Причини появи технічного боргу:

* Тиск зі сторони бізнесу

    Виникає коли бізнес змушує викотити фічі раніше, ніж вони будуть повністю дороблені. В цьому випадку, в коді з’являються заплатки та розпорки, які приховують недороблені частини проекту.

* Відсутність розуміння наслідків технічного боргу

    Виникає коли бізнес не розуміє, що темпи розробки уповільнюються, якщо за командою тягнеться технічний борг. Через це занадто складно виділити час команди на рефакторинг, так як керівництво не бачить в цьому цінності.

* Відсутність боротьби з жорсткою обмеженістю компонентів

    Це коли проект нагадує моноліт, а не зв’язок окремих модулів. У цьому випадку будь-які зміни однієї частини проекту зачіпають інші. Командна розробка утруднена, так як складно ізолювати ділянки роботи окремих людей.

* Відсутність автотестів

    Відсутність негайного зворотного зв’язку заохочує швидкі, але ризиковані виправлення та розпорки, іноді прямо на продакшені. Ефекти від цього бувають катастрофічні. Наприклад, безневинний хот-фікс розсилає тестовий лист по всій базі клієнтів або видаляє реальні дані клієнтів в базі даних.

* Відсутність документації

    Відсутня або застаріла документація уповільнює введення нових людей в проект. Такий проект ризикує повністю застопоритися, якщо ключові співробітники залишать роботу.

* Відсутність взаємодії між членами команди

    Коли база знань не поширюється всередині організації, люди працюють із застарілим розумінням процесів і деталей проекту. Становище ускладнюється, коли молодші розробники неправильно навчаються їх наставниками.

* Довготривала одночасна розробка в декількох гілках

    Може викликати накопичення технічного боргу, який необхідно заповнити при злитті змін воєдино. Чим більше змін, які зроблені ізольовано, тим більше підсумковий технічний борг.

* Відкладений рефакторинг

    Вимоги до проекту постійно змінюються і в певний момент може стати очевидним, що частини коду застаріли, стали громіздкими та повинні бути перероблені під нові вимоги. З іншого боку, програмісти проекту кожен день пишуть новий код, який працює з застарілими частинами. Тому чим довше затримується рефакторинг, тим більше залежного коду доведеться перелопачувати в майбутньому.

* Відсутність контролю за дотриманням стандартів

    Кожен учасник проекту пише код так, як вважає за потрібне (так, як він писав на минулому проекті). В результаті код проекту перетворюється у салат зі стилів кодування, ускладнюючи розуміння коду для всіх членів команди.

* Відсутність компетенції

    Коли розробник просто не вміє писати якісний код.

== 3. Коли рефакторити

*Правило трьох*

. Роблячи щось в перший раз, ви просто це робите.
. Роблячи щось аналогічне вдруге, ви мружитеся від необхідності повторення, але все-таки повторюєте те ж саме.
. Роблячи щось схоже в третій раз, ви починаєте рефакторинг.

*Коли робите нову фічу*

* Рефакторинг допомагає зрозуміти чужий код. Якщо код, в який потрібно додати нову фічу, недостатньо ясний, рефакторинг дозволяє зробити його більш очевидними для вас і для того, хто буде працювати з ним в майбутньому.
* Рефакторинг полегшує написання нового коду. Після рефакторингу додавання нової фічі відбувається значно простіше і займає менше часу.

*Коли робите нову фічу*

Рефакторинг допомагає зрозуміти чужий код. Якщо код, в який потрібно додати нову фічу, недостатньо ясний, рефакторинг дозволяє зробити його більш очевидними для вас і для того, хто буде працювати з ним в майбутньому.

Рефакторинг полегшує написання нового коду. Після рефакторингу додавання нової фічі відбувається значно простіше і займає менше часу.

*Під час код-рев’ю*

Коли ви робите рев’ю нової фічі, можливо це останній шанс почистити код, перед тим як він стане доступним публічно.

Найкраще проводити таке рев’ю разом з автором коду. У цьому випадку, ви будете пропонувати автору зміни, а потім разом вирішувати, наскільки складно зробити ту чи іншу зміну. Водночас, невеличкі зміни можна буде здійснювати дуже швидко.

== 4. Як рефакторити код
Рефакторинг слід проводити серією невеликих змін, кожна з яких робить існуючий код трохи краще, залишаючи програму в робочому стані.

*Чек-ліст правильно проведеного рефакторингу:*

* [*] Код повинен стати чистішим.

Якщо після рефакторингу код залишився таким же брудним... Що ж, шкодую, ви тільки що витратили даремно час свого життя. Але хоча б розберіться чому це сталося. Найчастіше це трапляється тоді, коли ви відходите від проведення рефакторингу дрібними змінами і змішуєте купу рефакторингів в одну величезну зміну. Так дуже легко втратити голову і наробити помилок, особливо, якщо ви обмежені в часі. Але таке буває і при роботі з особливо занедбаним кодом. Що б ви не поліпшили, код в цілому все одно залишається потворним. У цьому разі покращити код можна тільки повністю переписавши якісь його частини. Але пам’ятайте, що перед цим у вас повинні бути написані тести, а також запланований неабиякий шматок вільного часу.

* [*] В процесі рефакторингу НЕ створюється нова функціональність.

Не змішуйте рефакторинг і безпосередню розробку нових фічей. Намагайтеся розділяти ці процеси хоча б в рамках окремих комітів.

* [*] Всі існуючі тести повинні успішно проходити.

Існують два випадки, коли після рефакторингу ламаються тести:

* *Ви допустили помилку при зміні коду.* Тут все просто - йдіть і виправте помилку.
* *Ваші тести були занадто низькорівневими.* Частіше за все, це трапляється тоді, коли ваші тести перевіряють роботу приватних методів класів.

У цьому разі винні тести, тому вам треба або відрефакторити їх, або написати нові, більш високорівневі. Такої ситуації можна взагалі уникнути, створюючи тести в стилі https://uk.wikipedia.org/wiki/%D0%9A%D0%B5%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B0_%D0%BF%D0%BE%D0%B2%D0%B5%D0%B4%D1%96%D0%BD%D0%BA%D0%BE%D1%8E_%D1%80%D0%BE%D0%B7%D1%80%D0%BE%D0%B1%D0%BA%D0%B0[BDD].