== 4. Забрюднювачі коду

Забрюднювачі коду являють собою щось зайве, від чого можна було б позбутися, зробивши код чистіше, ефективніше і простіше для розуміння.

=== 4.1. Коментарі (Comments)

*Симптоми і ознаки*

Метод містить безліч пояснювальних коментарів.

*Причини появи*

Здебільшого, автор керується найдобрішими намірами при створенні коментарів. Він сам розуміє, що його код недостатньо очевидний і зрозумілий. У таких випадках коментарі грають роль «дезодоранту», тобто намагаються заглушити «поганий запах» недостатньо опрацьованого коду.

Найкращий коментар — це хороша назва методу або класу.

Якщо ви відчуваєте, що фрагмент коду буде незрозумілим без коментаря, спробуйте змінити структуру коду таким чином, щоби будь-які коментарі стали зайвими.

*Лікування*

* Якщо коментар призначений для того, щоби пояснити складний вираз, можливо, цей вираз краще розбити на більш зрозумілі підвирази за допомогою відокремлення змінної.
* Якщо коментар пояснює цілий блок коду, можливо, цей блок можна витягнути в окремий метод за допомогою відокремлення методу. Назву нового методу вам, скоріш за все, підкаже сам коментар.
* Якщо метод вже виділений, але для пояснення його дії, як і раніше, потрібен коментар, дайте методу нову назву, що не вимагає коментаря. Використайте для цього перейменування методу.
* Якщо потрібно описати якість правила, що стосуються корректної роботи метода, спробуйте рефакторинг введення твердження.

*Виграш*

Код стає очевиднішим і зрозумілішим.

*Не варто чіпати, якщо...*

Іноді коментарі бувають корисними:

* Ті, що пояснюють чому щось виконується саме таким чином.
* Ті, що пояснюють складні алгоритми (коли всі інші засоби спрощення алгоритму вже були випробувані).

=== 4.2. Дублювання коду (Duplicate Code)

*Симптоми і ознаки*

Два фрагменти коду виглядають майже однаковими.

*Причини появи*

У більшості випадків дублювання виникає тоді, коли в проекті працюють декілька авторів, причому над різними його частинами. Вони працюють над схожими задачами, але не знають, що колега вже написав схожий код, який можна використати замість написання свого.

Зустрічається і непряме дублювання, коли конкретні ділянки коду відрізняються зовні, хоча і виконують одну і ту ж задачу. Таке дублювання буває досить складно виявити і виправити.

В окремих випадках дублювання створюється навмисно. Найчастіше в поспіху, коли строки здачі проекту горять. Програміст-початківець бачить у вже написаному коді «майже такий, як треба» фрагмент, і не може встояти від спокуси просто скопіювати його як є і вставити десь в іншому місці (і так десяток разів).

В інших випадках програміст просто занадто ледачий, щоби позбавити код від дублювання.

*Лікування*

* Одна і та ж ділянка коду присутня в двох методах одного і того ж класу: необхідно застосувати відокремлення методу, після чого викликати код створеного методу з обох ділянок.
* Одна і та ж ділянка коду присутня в двох підкласах, що знаходяться на одному рівні:
** Необхідно застосувати відокремлення методу для обох класів з подальшим підйомом поля для полів, які використовуються в піднятому методі.
** Якщо спільний код знаходиться в конструкторі, слід використати підйом тіла конструктора.
** Якщо ділянки коду схожі, але не співпадають повністю, треба користуватися створення шаблонного методу.
** Якщо обидва методи роблять одне і те ж, але за допомогою різних алгоритмів, можна вибрати чіткіший з цих алгоритмів і застосувати заміщення алгоритму.
* Код, що дублюється, знаходиться в двох різних класах:
** Якщо ці класи не є частиною якоїсь ієрархії, слід використати відокремлення суперкласу, щоб створити для цих класів один суперклас, що містить усю спільну функціональність.
** Якщо створення суперкласу небажане або неможливе, слід застосувати відокремлення класу в одному класі, а потім використати новий компонент в іншому.
* Якщо присутня низка умовних операторів, які виконують один і той же код і відрізняються тільки умовами, слід об’єднати ці оператори в один із загальною умовою за допомогою об’єднання умовних операторів, а також застосувати відокремлення методу, щоб винести цю умову в окремий метод із зрозумілою назвою.
* Однаковий код виконується в усіх гілках умовного оператора: необхідно винести однаковий код за межі умовного оператора за допомогою об’єднання фрагментів з дублюванням коду в умовних операторах.

*Виграш*

* Об’єднання коду, що дублюєтся, дозволяє поліпшити структуру коду і зменшити його об’єм.
* Це, у свою чергу, веде до спрощення і здешевлення підтримки коду в майбутньому.

*Не варто чіпати, якщо...*

В окремих випадках об’єднання двох однакових ділянок коду може зробити код менш очевидним і зрозумілим.

=== 4.3. Ледачий клас (Lazy Class)

*Симптоми і ознаки*

На розуміння і підтримку класів завжди потрібно витрачати час і гроші. А тому, якщо клас не робить досить багато, щоби приділяти йому достатньо уваги, він має бути знищений.

*Причини появи*

Це може статися, якщо клас був задуманий як повнофункціональний, але в результаті рефакторингу зменшився до непристойних розмірів.

Або клас створювався з розрахунку на деякі майбутні розробки, до яких руки так і не дійшли.

*Лікування*

* Для компонентів, які мають дуже мало корисних елементів, необхідно провести вбудовування класу.
* За наявності підкласів з недостатніми функціями спробуйте згортання ієрархії.

*Виграш*

* Зменшення розміру коду.
* Спрощення підтримки.

*Не варто чіпати, якщо...*

Іноді Ледачий клас буває створений для того, щоб явно окреслити якісь наміри. В цьому випадку варто дотримуватися балансу зрозумілості коду і його простоти.

=== 4.4. Клас даних (Data Class)

*Симптоми і ознаки*

Класи даних — це класи, які містять тільки поля і прості методи для доступу до них (геттери і сеттери). Це просто контейнери для даних, які використовуються іншими класами. Ці класи не містять ніякої додаткової функціональності і не можуть самостійно працювати з даними, якими володіють.

*Причини появи*

Це нормально, коли клас на початку свого життя містить усього лише декілька публічних полів (а може навіть і парочку геттерів/сеттерів). Проте, справжня сила об’єктів полягає в тому, що вони можуть зберігати типи поведінки або операції над власними даними.

*Лікування*

* Якщо клас містить публічні поля, застосуйте інкапсуляцію поля щоби приховати їх з прямого доступу, дозволивши доступ тільки через геттери і сеттери.
* Застосуйте інкапсуляцію колекції для даних, які зберігаються в колекціях (на зразок масивів).
* Огляньте клієнтський код, який використовує цей клас. Можливо, там ви знайдете функціональність, яка виглядала б доречніше в самому класі даних. В цьому випадку використайте переміщення методу і відокремлення методу для перенесення функціональності в клас даних.
* Після того, як клас наповнився осмисленими методами, можливо, варто подумати про знищення старих методів доступу до даних, які дають занадто відкритий доступ до даних класу. В цьому вам допоможе видалення сеттера і приховання методу.

*Виграш*

* Покращує розуміння і організацію коду. Операції над певними даними тепер зібрані в одному місці, їх не потрібно шукати по всьому коду.
* Може розкрити факти дублювання клієнтського коду.

=== 4.5. Мертвий код (Dead Code)

*Симптоми і ознаки*

Змінна, параметр, поле, метод або клас більше не використовуються (найчастіше тому, що застаріли).

*Причини появи*

Коли вимоги до програмного продукту змінилися, або були внесені якісь коригування, але чистка старого коду не відбулася.

Мертвий код можна знайти в складному умовному коді, коли одна з гілок ніколи не може бути виконана (через наявність помилки або іншого збігу обставин).

*Лікування*

* Краще за все мертвий код виявляється за допомогою якісного середовища розробки (IDE).
* Видаліть невживаний код і зайві файли.
* Непотрібних класів можна позбутися за допомогою вбудовування класу. Якщо в такого класа є підкласи чи суперклас, то підійте згортання ієрархії.
* Для видалення непотрібних параметрів використайте видалення параметру.

*Виграш*

* Зменшує розмір коду.
* Спрощує його підтримку.

=== 4.6. Теоретична спільність (Speculative Generality)

*Симптоми і ознаки*

Клас, метод, поле або параметр не використовуються.

*Причини появи*

Іноді код створюється «про запас», щоби підтримувати якийсь можливий майбутній функціонал, який так і не реалізується. В результаті цей код стає важче розуміти і супроводжувати.

*Лікування*

* Для видалення незадіяних абстрактних класів використайте згортання ієрархії.
* Зайве делегування функціональності іншому класу може бути видалене за допомогою вбудовування класу.
* Від невживаних методів можна позбутися за допомогою вбудовування методу.
* Методи з невживаними параметрами потрібно передати видаленню параметрів.
* Зайві поля можна просто видалити.

*Виграш*

* Зменшення розміру коду.
* Спрощення підтримки.

*Не варто чіпати, якщо...*

* У випадках, коли ви працюєте над фреймворком, створення функціональності, що не буде використовуватись самим фреймворком, цілком виправдане. Головне, щоб вона була потрібна користувачам фреймворка.
* Перед видаленням елементів варто впевнитися, чи не використовуються вони в юніт-тестах. Таке буває, якщо тести потребують способу отримання якоїсь службової інформації класу або здійснення якихось спеціальних тестових дій.

