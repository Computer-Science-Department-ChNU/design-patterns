== 1. Роздувальщики

Раздувальщики представляють код, методи і класи, які роздулися до таких великих розмірів, що з ними стало неможливо ефективно працювати. Всі ці запахи часто не з'являються відразу, а наростають в процесі еволюції програми (особливо коли ніхто не намагається боротися з ними).

=== 1.1. Довгий метод (Long Method)
*Симптоми і ознаки*

Метод містить занадто багато коду. Довжина методу більше десяти рядків повинна починати вас турбувати.

*Причини появи*

В метод весь час щось додається, але нічого не виноситься. Оскільки писати код набагато простіше, ніж читати, цей запах довго залишається непоміченим — аж поки метод не перетвориться на справжнього монстра.

Варто пам’ятати, що людині ментально складніше створити новий метод, ніж дописати щось у вже існуючий: «Мені потрібно додати всього два рядки, не буду ж я створювати заради цього цілий метод».

Таким чином додається один рядок за іншим, внаслідок чого метод перетворюється на велику тарілку спагеті.

*Лікування*

Слід дотримуватися такого правила: якщо відчувається необхідність щось прокоментувати всередині методу, цей код краще виділити в новий метод. Навіть один рядок має сенс виділяти в метод, якщо він потребує роз’яснень. До того ж, якщо метод має гарну назву, то не потрібно буде дивитися в код заради розуміння, що ж він робить.

* Для скорочення тіла методу досить застосувати відокремлення методу.
* Якщо локальні змінні і параметри перешкоджають виділенню методу, можна застосувати заміну тимчасової змінної викликом методу, заміну параметрів об’єктом і передачу всього об’єкта.
* Якщо і вони не допомогли, можна спробувати виділити весь метод в окремий об’єкт за допомогою заміни методу об’єктом методів.
* Умовні оператори і цикли свідчать про можливість виділення коду в окремий метод. Для роботи з умовними виразами підійде декомпозиція умовних операторів. Для роботи з циклом — відокремлення методу.

*Виграш*

* З усіх видів об’єктного коду найкраще виживають класи з короткими методами. Чим довше ваш метод або функція, тим важче буде її зрозуміти і підтримувати.
* Крім того, в довгих методах найчастіше зустрічаються «поклади» дублювання коду.

*Швидкодія*

Багато хто хвилюється, що збільшення числа методів може погано позначитися на швидкодії програми. В абсолютній більшості випадків це не є реальною проблемою, а тому — досить про це хвилюватися!

Маючи чистий і зрозумілий код, ви з більшою вірогідністю побачите класний варіант реструктуризації коду програми і збільшення реальної продуктивності.


=== 1.2. Занадто великий клас (Large Class)
*Симптоми і ознаки*

В класі безліч полів/методів/рядків коду.

*Причини появи*

Як правило, спочатку класи не бувають занадто великими. Але з часом у зв’язку з розвитком програми багато хто з них «роздувається».

Як і у випадку з довгими методами, найчастіше програмістові ментально простіше додати фічу в існуючий клас, ніж створювати новий клас для цієї фічі.

*Лікування*

Коли клас реалізує занадто об’ємний функціонал, варто подумати про його розділення:

* Відокремлення класу допоможе, якщо частина поведінки великого класу може бути виділена в свій власний компонент.

* Відокремлення підкласу допоможе, якщо частина поведінки великого класу може мати альтернативні реалізації або використовується лише в окремих випадках.

* Відокремлення інтерфейсу допоможе, якщо вам потрібно мати список операцій і поведінки, яку клієнт зможе використовувати.

* В класах графічного інтерфейсу часто можна знайти дані і поведінки, які не відносяться до безпосереднього виводу інтерфейсу, а скоріше відповідають за його загальну логіку роботи. Такі дані і поведінки слід виділити в окремий клас предметної області, який би керував роботою графічного інтерфейсу. Також при цьому може виявитися необхідність зберігати копії деяких даних в двох місцях і забезпечувати їх узгодженість. Дублювання видимих даних пропонує шлях, яким можна це здійснити.

*Виграш*

* Рефакторинг таких класів позбавить розробників від необхідності запам’ятовувати надмірну кількість атрибутів класу.

* У багатьох випадках розділення великих класів на частини дозволяє уникнути дублювання коду і функціональності.


=== 1.3. Одержимість елементарними типами (Primitive Obsession)

*Симптоми і ознаки*

* Використання елементарних типів замість маленьких об’єктів для невеликих завдань (наприклад, валюта, діапазони, спеціальні рядки для телефонних номерів і тому подібне).

* Використання констант для кодування якоїсь інформації (наприклад, константа USER_ADMIN_ROLE = 1 для позначення користувачів з роллю адміністратора).

* Використання рядкових констант як назв полів в масивах.

*Причини появи*

Як і більшість інших запахів, цей розпочинається з маленької слабкості. Програмістові знадобилося поле для зберігання якихось даних. Він подумав, що створити поле елементарного типу куди простіше, ніж новий клас. Це й було зроблено. Потім знадобилося інше поле, і воно також було додане схожим чином. А потім не встигли ви озирнутися, як клас вже збільшився до грандіозних розмірів.

Примітивні типи досить часто використовуються для «симуляції» типів. Це коли замість окремого типу даних у вас є декілька чисел або рядків, які складаються в список допустимих значень для якоїсь сутності. Найчастіше цим конкретним числам і рядкам дають зрозумілі імена за допомогою констант, що і стає причиною їх широкого поширення.

Ще одним поганим методом використання примітивних типів є «симуляція» полів. При цьому клас містить великий масив різноманітних даних, а в ролі індексів масиву для отримання цих даних використовуються строкові константи, задані в класі.

*Лікування*

* Якщо ви маєте безліч різноманітних полів примітивних типів, можливо, деякі з них можна логічно згрупувати і перенести в свій власний клас. Ще краще, якщо в цей клас ви зможете перенести і поведінку, пов’язану з цими даними. Впоратися з цією проблемою допоможе заміна значення даних об’єктом.

* Якщо значення цих полів використовуються в параметрах методів, використайте заміну параметрів об’єктом або передачу всього об’єкта.

* У випадках, коли в змінних закодовані якісь складні дані, використайте заміну кодування типу класом, заміну кодування типу підкласами або заміну кодування типу станом/стратегією.

* Якщо серед змінних є масиви, використайте заміну масиву об’єктом.

*Виграш*

* Підвищує гнучкість коду завдяки використанню об’єктів замість примітивних типів.

* Покращує розуміння і організацію коду. Операції над певними даними тепер зібрані в одному місці, і їх не потрібно шукати по всьому коду. Тепер не треба здогадуватися, навіщо створені всі ці дивні константи і чому поля містяться в масиві.

* Може розкрити факти дублювання коду.


=== 1.4. Довгий список параметрів (Long Parameter List)

*Симптоми і ознаки*

Кількість параметрів методу більше трьох-чотирьох.

*Причини появи*

Довгий список параметрів може з’явитися після об’єднання декількох варіантів алгоритмів в одному методі. В цьому випадку може бути створений довгий список параметрів, контролюючих те, яка з варіацій буде виконана і як.

Поява довгого списку параметрів також може бути пов’язана із спробою програміста зменшити зв’язаність між класами. Наприклад, код створення конкретних об’єктів, потрібних в методі, перенесли з самого методу в код виклику цього методу, а створені об’єкти вирішили передавати в метод як параметри. Таким чином, оригінальний клас перестав знати про зв’язки між об’єктами, і зв’язність зменшилася.

Але якщо з’являється потреба в декількох таких об’єктах, для кожного з них знадобиться свій власний параметр, що призводить до розростання списку параметрів.

У довгих списках параметрів важко орієнтуватися, вони стають суперечливими і складними у використанні. Замість довгого списку параметрів метод може використовувати дані свого власного об’єкта. Якщо всіх необхідних даних в поточному об’єкті немає, в якості параметра методу можна передати інший об’єкт, який отримає відсутні дані.

*Лікування*

* Якщо дані, які передаються в метод, можна отримати шляхом виклику методу іншого об’єкта, застосовуємо заміну параметра викликом методу. Цей об’єкт може бути розташованим у полі власного класу або переданий як параметр методу.

* Замість того щоби передавати групу даних, отриманих з іншого об’єкта в якості параметрів, можна передати в метод сам об’єкт, використовуючи передачу всього об’єкта.

* Якщо є декілька незв’язаних елементів даних, іноді їх можна об’єднати в один об’єкт-параметр, застосувавши для цього заміну параметрів об’єктом.

*Виграш*

* Підвищує читабельність коду, зменшує його розмір.

* В процесі рефакторингу ви зможете виявити дублювання коду, яке раніше було непомітним.

*Не варто чіпати, якщо...*

Не варто позбавлятися від параметрів, якщо при цьому з’являється небажана зв’язаність між класами.


=== 1.5. Групи даних (Data Clumps)

*Симптоми і ознаки*

Іноді в різних частинах коду зустрічаються однакові групи змінних (наприклад, параметри підключення до бази даних). Такі групи слід перетворювати на самостійні класи.

*Причини появи*

Поява груп даних є наслідком поганої структурованості програми або програмування методом копіювання-вставки.

Щоб виявити групу даних, достатньо видалити одне зі значень даних і перевірити, чи збережуть сенс інші. Якщо ні, це вірна ознака того, що група змінних напрошується на об’єднання їх в об’єкт.

*Лікування*

* Якщо дані, що повторюються, є полями якогось класу, використайте відокремлення класу для переміщення полів у власний клас.

* Якщо ті ж групи даних передаються в параметрах методів, використайте заміну параметрів об’єктом щоб виділити їх в спільний клас.

* Якщо деякі з цих даних передаються в інші методи, подумайте про можливість передачі в метод усього об’єкта даних замість окремих полів (у цьому допоможе передача всього об’єкта).

* Подивіться на код, який використовує ці поля. Можливо, має сенс перенести цей код в клас даних.

*Виграш*

* Покращує розуміння і організацію коду. Операції над певними даними тепер зібрані в одному місці, їх не потрібно шукати за всім кодом.

* Зменшує розмір коду.

*Не варто чіпати, якщо...*

Передача всього об’єкта в параметрах методу замість передачі його значень (елементарних типів) може створити небажану залежність між двома класами.