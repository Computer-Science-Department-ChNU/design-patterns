== 2. Порушники об'єктно-орієнтованого дизайну

Всі ці запахи являють собою неповне або неправильне використання можливостей об’єктно-орієнтованого програмування.

=== 2.1. Оператори switch (Switch Statements)

*Симптоми і ознаки*

У вас є складний оператор switch або послідовність if -ів.

*Причини появи*

Однією з очевидних ознак об’єктно-орієнтованого коду служить порівняно рідкісне використання операторів типу switch або case. Часто один і той же блок switch виявляється розкиданим по різних місцях програми. При додаванні в нього нового варіанту доводиться шукати всі ці блоки switch і модифікувати їх.

Як правило, помітивши блок switch, слід подумати про поліморфізм.

*Лікування*

* Щоб ізолювати switch і помістити його в потрібний клас може знадобитися відокремлення методу і переміщення методу.
* Якщо switch перемикається за допомогою коду типу, наприклад, перемикається режим виконання програми, то слід використати заміну кодування типу підкласами або заміну кодування типу станом/стратегією.
* Після налаштування структури наслідування слід використати заміну умовного оператора поліморфізмом.
* Якщо варіантів в операторі не дуже багато і всі вони призводять до виклику одного й того ж методу з різними параметрами, то введення поліморфізму буде надмірним. В цьому випадку варто замислитися про розбиття цього методу на декілька різних, які виконуватимуть кожен свої функції, для чого треба застосувати заміну параметра набором спеціалізованих методів.
* Якщо одним з варіантів умовного оператора є null, використайте введення Null-об’єкта.

*Виграш*

Покращує організацію коду.

*Не варто чіпати, якщо...*

* Коли оператор switch виконує прості дії, немає ніякого сенсу щось міняти в коді.
* Часто буває, що оператор switch використовується у фабричних патернах проектування (Фабричний метод, Абстрактна фабрика), для вибору створюваного класу.


=== 2.2. Тимчасове поле (Temporary Field)

*Симптоми і ознаки*

Тимчасові поля — це поля, які потрібні об’єкту лише час від часу. Тільки тоді вони заповнюються якимись значеннями, залишаючись порожніми решту часу.

*Причини появи*

Найчастіше тимчасові поля створюються для використання в алгоритмі, який вимагає великого числа вхідних даних. Так, замість створення великого числа параметрів в такому методі програміст вирішує створити для цих даних поля в класі. Ці поля використовуються тільки в цьому алгоритмі, а решту часу простоюють.

Такий код дуже важко зрозуміти. Ви очікуєте побачити дані в полях об’єкта, а вони чомусь порожні майже весь час.

*Лікування*

* Тимчасові поля і весь код, що працює з ними, можна перемістити в свій власний клас за допомогою відокремлення класу. По суті, ви таким чином створюєте об’єкт-метод.
* Введіть Null-об’єкт і вбудуйте його замість коду перевірки наявності значень в тимчасових полях.

*Виграш*

Покращує зрозумілість і організацію коду.


=== 2.3. Відмова від спадку (Refused Bequest)

*Симптоми і ознаки*

Якщо підклас використовує лише малу частину успадкованих методів і властивостей суперкласа, це є ознакою неправильної ієрархії. При цьому зайві методи можуть просто не використовуватися або бути перевизначеними і викидати виключення.

*Причини появи*

Хтось створив наслідування між класами тільки з мотивів повторного використання коду, що знаходиться в суперкласі. При цьому суперклас і підклас можуть бути абсолютно різними сутностями.

*Лікування*

* Якщо наслідування не має сенсу, і підклас насправді не є представником суперкласу, слід позбутися від відношення наслідування між цими класами, застосувавши заміну наслідування делегуванням.
* Якщо наслідування має сенс, треба позбутися від зайвих полів і методів в підкласі. Для цього необхідно витягнути з батьківського класу всі поля і методи, які потрібні підкласу, в новий суперклас, і зробити обидва класи його спадкоємцями (відокремлення суперкласу).

*Виграш*

Покращує розуміння і організацію коду. Тепер ви не витрачатимете час на припущення, чому саме клас Стілець є підкласом класу Тварина ([.line-through]#незважаючи на те, що в обох є чотири ноги#).


=== 2.3. Альтернативні класи з різними інтерфейсами (Alternative Classes with Different Interfaces)

*Симптоми і ознаки*

Два класи виконують однакові функції, але мають різні назви методів.

*Причини появи*

Програміст, який створив один з класів, скоріше за все, не знав, що в програмі вже існує аналогічний за функціоналом клас.

*Лікування*

* Потрібно привести інтерфейс класів до спільного знаменника:
* Перейменуйте методи таким чином, щоб вони стали однаковими для всіх альтернативних класів.
* Скористайтеся переміщенням методу, додаванням параметру і параметризацією методу для того, щоб сигнатура і реалізація методів стали однаковими.
* Якщо ідентичною є тільки частина функціональності класів, спробуйте відокремити цю частину в спільний суперклас. При цьому існуючі класи стають підкласами.

Після того, як ви визначилися з варіантом «лікування» і здійснили його, подумайте, можливо, один з класів тепер можна видалити.

*Виграш*

* Ви позбавляєтесь від зайвого дублювання коду, і, таким чином, зменшуєте його розмір.
* Підвищується читабельність коду, поліпшується його розуміння. Вам більше не доведеться гадати, навіщо створювався другий клас, який виконує точно такі ж функції, як і перший.


*Не варто чіпати, якщо...*

Іноді об’єднання класів виявляється неможливим або настільки складним, що сенсу займатися цією роботою немає. Один із прикладів — альтернативні класи знаходяться в двох різних бібліотеках, кожна з яких має свою версію класу.